class FLxER.core.FlxerSSConnector {	var nc:NetConnection;	var myRemote_so:SharedObject;	var broadcastXml;	var broadcastStatus:Boolean;	var broadName:String;	//	var trgt	var sender	//	var socket:XMLSocket	var c;	function FlxerSSConnector(t,s) {		trgt = t;		sender = s;		socket = new XMLSocket()		socket.trgt = t		socket.onConnect = function (success:Boolean) {			if (success) {				trace ("Connection succeeded!")			} else {				trace ("Connection failed!")			}		}		socket.onData = function (data) {			trgt.createList(this.data)			trace ("Connection succeeded!"+data)		}	}	function FlxerSSConnector(server) {		c = setInterval(this, unableToConnect, 3000);		socket.connect(server, 18000)		if (!) {			trace ("Connection failed!")		}	}	function unableToConnect(server) {		clearInterval(c);		trace("myConnector "+server)		nc.onStatus = function(infoObject) {			trace(infoObject.code)			/*if (infoObject.code == "NetConnection.Connect.Success") {				owner.myBroadName._visible = true;				owner.myBroadStartSend._visible = true;				owner.myBroadPlay._visible = true;				owner.myBroadSend._visible = true;				owner.O._visible = true;				owner.S._visible = true;				owner.C._visible = true;			}			if (infoObject.code == "NetConnection.Connect.Failed" or infoObject.code == "NetConnection.Connect.Rejected") {				owner.myServerSel.lab.lab.enabled = true;				owner.myBroadOnOff.myStatus_swap();			}*/		};		nc.connect(server);		myRemote_so = SharedObject.getRemote("flxerLS", nc.uri, false);		myRemote_so["owner"] = this;		myRemote_so.onSync = function(list) {			this["owner"].updatebroadcastXml();		};		myRemote_so.connect(nc);	}	function updatebroadcastXml() {		broadcastXml = new XML("<lib></lib>");		trace(myRemote_so.data)		for (var item in myRemote_so.data.broadArray) {			trace("cazzo "+item)			trace("cazzo "+item.n)			broadcastXml.childNodes[0].insertBefore(broadcastXml.createElement("broad"), broadcastXml.childNodes[0].childNodes[0]);			broadcastXml.childNodes[0].childNodes[0].attributes.m = item.n;			broadcastXml.childNodes[0].childNodes[0].attributes.val = item.n+","+item.w+","+item.h;		}		trgt.setStreamName(broadcastXml)	}	function broadSend(p) {		trace("broadSend"+p)		broadName = p;		myRemote_so["owner"] = this;		broadcastStatus = sender;		var broadNameObj = new Object();		broadNameObj.n = p;		broadNameObj.val = "";		broadNameObj.w = Stage.width;		broadNameObj.h = Stage.height;		if (!myRemote_so.data.broadArray) {			myRemote_so.data.broadArray = [];		}		myRemote_so.data[broadName] =broadNameObj;		if (sender) {			myRemote_so.onSync = function(list) {			};		} else {			trace("cazzooooooooooooooooooo")						myRemote_so.onSync = function(list) {				_root.monitor.mbuto(this.data[this["owner"].broadName].val.substring(3, this.data[this["owner"].broadName].val.length-4));			};		}		trace("PPPPPPPPPPPPPPPPPPP"+myRemote_so.data.broadArray)		for (var item in myRemote_so.data.broadArray) {			trace(item)			trace(item.n)		}	}}