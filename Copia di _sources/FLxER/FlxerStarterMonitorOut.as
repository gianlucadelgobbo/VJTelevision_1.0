package FLxER{	import flash.display.Sprite;	import flash.display.StageAlign;    import flash.display.StageScaleMode;	import flash.xml.XMLDocument;	import flash.events.*;	import flash.utils.*;	import flash.net.SharedObject;	import flash.net.LocalConnection;	import flash.net.URLLoader;	import flash.net.URLRequest;	import flash.display.Loader;	import flash.system.fscommand;	//	import FLxER.core.FlxerInterface;	import FLxER.core.Monitor;	import FLxER.panels.Preloader;	import FLxER.panels.Mess;	public class FlxerStarterMonitorOut extends Sprite {		public var monitor		:Monitor;		//		var c					:uint;		var receiving_lc		:LocalConnection;		var startDelay			:uint;		var splash				:Preloader;		//var plugInLoader		:Loader;		var myAlert				:Mess;		var myPrefSO			:SharedObject;		var myLoader			:URLLoader;		var plugInLoader		:Loader;		public function FlxerStarterMonitorOut():void {			stage.scaleMode = StageScaleMode.NO_SCALE;			stage.align = StageAlign.TOP_LEFT;			stage.addEventListener(Event.RESIZE, resizer);			stage.showDefaultContextMenu = false;			fscommand("trapallkeys", true);			startDelay = 500;			Preferences.createPref(stage.stageWidth,stage.stageHeight)			splash = new Preloader(40338);			this.addChild(splash);			myPrefSO = SharedObject.getLocal("flxerPref","/",false);			if (myPrefSO.data.flxerPref == undefined) {				loadPref();			} else {				Preferences.pref.flxerPref = new XMLDocument();				Preferences.pref.flxerPref.ignoreWhite = true;				Preferences.pref.flxerPref.parseXML(myPrefSO.data.flxerPref);				if (Preferences.pref.flxerPref.childNodes[0].childNodes[4] == undefined) {					loadPref();				} else {					Preferences.updateCol();					c = setInterval(openOptions, 500);				}			}		}		function loadPref():void {			myLoader = new URLLoader(new URLRequest("preferences/flxerPref.xml"));			myLoader.addEventListener("complete", firstStartup);			myLoader.addEventListener("ioError", xmlNotLoaded);		}		function firstStartup(event:Event):void {			Preferences.pref.flxerPref = new XMLDocument();			Preferences.pref.flxerPref.ignoreWhite = true;			Preferences.pref.flxerPref.parseXML(myLoader.data);			Preferences.updateColObj(Preferences.pref.colBlack);			myPrefSO.data.flxerPref = Preferences.pref.flxerPref;			myPrefSO.flush();			c = setInterval(openOptions, 500);		}		function openOptions():void {			if (getTimer() > startDelay) {				clearInterval(c);				this.removeChildAt(0);				startup();				myAlert = new Mess(200, 100, "ALERT", "Drag this window on the monitor extension\n\nthat you want to use an then click OK\n\n", goFull);				stage.addEventListener(KeyboardEvent.KEY_DOWN, goFullKey);  				this.addChild(myAlert);			}		}		function goFullKey(event:Event):void {			this.removeChild(myAlert);			stage.removeEventListener(KeyboardEvent.KEY_DOWN, goFullKey);  			goFull()		}		function goFull():void {			stage.displayState = "fullScreen";    			resizer(null)		}		function xmlNotLoaded(event:Event):void {			trace("Data not loaded."+event);		}		public function startup():void {			if (Preferences.pref.flxerPref.childNodes[0].childNodes[2].attributes.value == "true") {				Preferences.pref.vKS = true;			} else {				Preferences.pref.vKS = false;			}			Preferences.pref.nCh = parseInt(Preferences.pref.flxerPref.childNodes[0].childNodes[0].attributes.value.toString());			if (Preferences.pref.nCh < 1) {				Preferences.pref.nCh = 1;			} else if (Preferences.pref.nCh > 7) {				Preferences.pref.nCh = 7;			} else if (isNaN(Preferences.pref.nCh)) {				Preferences.pref.nCh = 7;			}			interfaceDrawer();		}		function interfaceDrawer():void {			Preferences.pref.myPreviewActive = true;			monitor = new Monitor(0, 0, Preferences.pref.w, Preferences.pref.h, Preferences.pref.nCh, false);			this.addChild(monitor);			resizer(null)			receiving_lc = new LocalConnection();			receiving_lc.client = this;            try {				receiving_lc.connect("lc_flxer");            } catch (error:ArgumentError) {                trace("Can't connect...the connection name is already being used by another SWF");            }		}		public function mbuto(a:String):void {			trace("monitor.mbuto(a)")			monitor.mbuto(a);		};		public function getMonitor():void {			var sending_lc = new LocalConnection();			sending_lc.send("lc_mon", "setMonitor", Preferences.pref.monObj);		}		public function loadPlugIn(p:String):void {			this.plugInLoader = new Loader();			plugInLoader.contentLoaderInfo.addEventListener(Event.INIT, initHandlerPlugIn);			plugInLoader.contentLoaderInfo.addEventListener(SecurityErrorEvent.SECURITY_ERROR, errorHandlerPlugIn);			plugInLoader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, errorHandlerPlugIn);			plugInLoader.load(new URLRequest("plug-in/"+p));			trace("loadPlugIn "+p);		}		function initHandlerPlugIn(event:Event) {			this.addChild(plugInLoader)			plugInLoader.content.avvia(Plugin)			trace("initHandlerPlugIn"+event)		}		function errorHandlerPlugIn(event:Event) {			trace("errorHandlerPlugIn"+event)		}/**/		function resizer(event:Event):void {			trace("resizer"+event)			monitor.resizer(stage.stageWidth,stage.stageHeight);			var monObj:Object = new Object();			monObj.monWidth = stage.stageWidth;			monObj.monHeight = stage.stageHeight;			Preferences.pref.monObj = monObj;		}		function resetta():void {			myPrefSO.clear();			var tmp = new XML(flxerPref.childNodes[0]);			myPrefSO.data.flxerPref = tmp;			myPrefSO.flush();			interfaceDrawer();		}	}}